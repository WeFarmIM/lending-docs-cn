---
description: 使用抵押品来防范违约风险，当触发清算条件时，抵押品将被清算
---

# 风控模型

## **参数定义**

1. \_targetAccountAddr: 地址类型，尝试清算的用户账号.
2. \_targetToken: 地址类型，被清算用户的 ERC20 代币地址.

## 设计概述

在可清算前提下，通过调用这个函数，调用者试图购买从 WeFarm 借了一些目标代币的目标账户的抵押品。调用者可以从 ChainLink 以 5%折扣的价格购买抵押品，合约使用收到的代币偿还目标账户的债务。调用者用于清算目标账户的资金应该已经存入 WeFarm，而不是在清算功能中转入 WeFarm。

目标账户可以有多种抵押品代币; 在这种情况下，合约让调用方按照每个代币的市场流动性顺序购买这些代币。假设市场流动性为 ETH>USDT>DAI>USDC，目标账户以 ETH、DAI 和 USDC 作为抵押品，并借入一些 USDT，并且它是可变现的。调用者已存入一些 USDT，并试图清算目标帐户。该函数将首先计算调用者可以发送到目标的最大 USDT，以确保调用者帐户的借 ETH 不会超过其借出能力。调用者将尝试先用 USDT 购买 ETH，价格比 chainlink 的价格低 5%。如果出售所有的 ETH 足以使目标帐户的 LTV 小于等于 60%，确保其借出能力大于或等于它借 ETH，或调用者的最大可转换的数量的 USDT 不足以购买所有的 ETH，我们停止清算过程。否则，它将尝试从目标购买 DAI，然后尝试购买 USDC。

请检查 `伪代码` 描述部分以获得更清晰的描述。

为了能够实现清算流程，一个账户的 LTV 应该在 85%\~95%之间。如果 LTV 大于 85%，那么这个账户就面临着无法偿还债务的高风险。但如果 LTV 大于 95%，则该账户的抵押物不足以让其他账户进行清算，因为其他账户会以 5%的折现率购买该账户的抵押物。

### **术语**

**CBB**: $当前借款金额 = 借款金额 + 已产生利息$

**MMRCV**: $维持最低要求的抵押品价值 = 当前借款金额 CBB / 维持 LTV 比率$

**LDR:** 清算折扣比率: 清算人在清算过程中购买他人资产所得到的折现率。

**CMPL**: 抵押品清算时的市场价格: 当清算事件发生时，标的抵押品的市场价格。

**CCV**: $当前的抵押品价值 = CMPL \times 抵押品数量$

**UAAL**: 清算时的用户资产: 可清算或交换的最大抵押品。

**ILTV**: 抵押品代币的初始 LTV 比率: 目前大多数代币为 0.6。

**UAALAD**: $被清算资产折现后价值 = 被清算用户当前资产 UAAL \times (1-LDR)$

我们需要确保: $(当前借款金额 - 被清算资产折现后价值) / (当前抵押品价值 - 被清算用户当前资产) \leq 抵押品代币的初始 LTV 比率$

$$
(CBB - (1-LDR) \times UAAL) / (CCV-UAAL) \leq ILTV
$$

通过转换公式得出: $清算时的用户资产 = (当前借款金额 - 当前的抵押品价值 \* 抵押品代币的初始 LTV 比率) / (1 - 清算折扣比率 - 抵押品代币的初始 LTV 比率)$

$$
UAAL \geq (CBB – CCV \times ILTV) / (1 - LDR - ILTV)
$$

## 举例说明

假设 WeFarm 协议只支持 4 种资产类型 ETH，USDT，DAI，和 USDC. 清算顺序为 ETH>USDT>DAI>USDC. 为了简化流程暂不涉及利息.

| 币名   | ETH | USDT | DAI | USDC |
| ---- | --- | ---- | --- | ---- |
| 清算顺序 | 1   | 2    | 3   | 4    |
| 价格   | 300 | 1    | 1   | 1    |

### 1. 目标帐户有一种抵押品，调用者试图清算并能充分清算

清算前:

用户 1:

1. 存款: 100 USDT
2. 贷款: 90 DAI
3. LTV: 0.9，可清算

用户 2:

1. 存款 100 DAI
2. 调用清算方法 liquidate(用户 1，DAI 币地址)

解析

用户 2 可以转移到用户 1 的 DAI 的最大数量是 100，因为它没有任何借款。

$$
UAAL = (90 - 1 * 100 * 0.6) / (1 - 0.05 - 0.6) = 85.7
$$

因为 DAI 的价格是 1，并且 85.7 < 100，所以用户 2 可以支付最大值 85.7 DAI。我们称之为完全清算。

清算后

用户 1:

1. 存款: 100 - 85.7 = 14.3 USDT
2. 贷款: 90-85.7\*0.95 = 8.6 DAI
3. LTV: 0.6，不可清算

用户 2:

1. 存款: 18.6 DAI，85.7 USDT

### 2. 目标帐户有一种抵押品，调用者试图清算，但只能部分清算

清算前:

用户 1:

1. 存款: 100 USDT
2. 贷款: 90 DAI
3. LTV: 0.9，可清算

用户 2:

1. 存款: 50 DAI
2. 调用清算方法 liquidate(用户 1，DAI 币地址)

解析:

在此，计算 UAAL 的方法与实例 1 相同。

$$
UAAL = (90 - 1 * 100 * 0.6) / (1 - 0.05 - 0.6) = 85.7
$$

但是本例子中，用户 2 只有 50 DAI 币，价值 50。因为 50 < 85.7，所以用户 2 不能交换最大的 UAAL 值. 那么，用户 2 只能支付 50 DAI，清算用户 1 贷款 50 / 0.95 = 52.6 USDT.

清算后:

用户 1:

1. 存款: 100 - 50/0.95 = 47.4 USDT
2. 贷款: 90-50 = 40DAI
3. LTV: 40 \* 1 / 47.4 \* 1 = 0.84，不可清算

用户 2:

1. 存款: 50/0.95 = 52.6 USDT

注意在本例子中，尽管用户 2 未能完全清算用户 1，用户 1 在部分清算后状态仍然变为不可清算。这是因为在借款 LTV 和清算 LTV 之间有一个距离.

### 3. 目标帐户有多种抵押品，调用者试图将用户全部变现

清算前:

用户 1:

1. 存款: 50 USDT，50 USDC
2. 贷款: 90 DAI
3. LTV: 0.9，可清算

用户 2:

1. 存款: 100 DAI
2. 调用清算方法 liquidate(用户 1，DAI 币地址)

在清算过程中，我们遍历 WeFarm 支持的所有代币。为了简化它，我在前面的两个示例中省略了它。 过程如下: 迭代一个代币时，我们计算一个 UAAL 值，如果目标帐户的存款有当前代币，并且代币价值大于 UAAL，这意味着清算当前类型的代币就足以使其借款价值低于其借贷能力，我们卖出 UAAL 价值代币给清算人，清算结束。否则，这意味着出售所有当前代币是不够的。我们将当前代币中的所有代币出售给清算人，并将此过程继续到下一个代币。在任何时候，如果 `target.borrowETH` < `target.borrowPower` 或 `liquidator.targetTokenBalance` = 0，我们结束这个清算过程。

关于流动性顺序，我们首先迭代 ETH，但目标在该代币中没有任何存款。我们跳过它。然后接下来是 USDT:

$$
UAAL = (90 - 1 * 100 * 0.6) / (1 - 0.05 - 0.6) = 85.7
$$

用户 1 的 USDT 存款只有 50，小于 85.7，我们清算全部 USDT:

在清算全部 USDT 之后:

用户 1:

1. 存款: 50 USDC
2. 贷款: 90 - 50 \* 0.95 = 42.5 DAI
3. LTV: 0.85，可清算

用户 2:

1. 存款: 50 USDT，100 - 50 \* 0.95 = 52.5 DAI

我们同样跳过清算 `DAI`，因为用户没有 `DAI` 存款. 最后我们清算 USDC:

$$
UAAL = (42.5 - 1 * 50 * 0.6) / (1 - 0.05 - 0.6) = 35.7
$$

用户 1 有足够的 USDC 存款，所以卖出 35.7 USDC 给 用户 2，清算流程结束.

清算 USDC 之后，整个清算流程结束:

用户 1:

1. 存款: 14.3 USDC
2. 贷款: 42.5 - 35.7 \* 0.95 = 8.6 DAI

用户 2:

1. 存款: 35.7 USDC，50 USDT，52.5 - 35.7 \* 0.95 = 18.6 DAI
